if(typeof siApp=='undefined' || siApp == null)
    siApp = angular.module('ngSiApp', []);

siApp.evalAttribute = function (scope, scopeOperation)
{
    scope.$safeApply(function () { scope.$eval(scopeOperation || angular.noop) })
};

siApp.extendOptions = function (defaults, element, attribute) {
    var options;
    if (element.attr(attribute)) {
        try {
            var opts = element.attr(attribute);
            options = $.parseJSON(opts.replace(/'/g, "\""));
        } catch (e) {
            options = new Object();
        }
    } else {
        options = new Object();
    }
    options = $.extend(defaults, options);
    return options;
};

siApp.directive('ngSiFade', function ()
{
    return function (scope, element, attrs)
    {
        element.css('display', 'none');
        scope.$watch(attrs.ngSiFade, function (value)
        {
            if (value)
            {
                element.fadeIn(200);
            } else
            {
                element.fadeOut(100);
            }
        });
    };
});

siApp.directive('ngSiDestroy', function ()
{
    return function (scope, element, attrs)
    {
        var elem = $(element);
        elem.on("remove", function ()
        {
            scope.$destroy();
        });
    };
});


siApp.directive('ngSiDate',["$parse", function ($parse) {
    return function (scope, element, attrs)
    {
        var elem = $(element);
        var defaultOptions = {
            //showOn: "both",
            //buttonImageOnly: true,
            //buttonImage: '../Content/images/calendar.png',
            changeMonth: true,
            changeYear: true,
            constrainInputType: true,
            dateFormat: 'd M yy'
        };

        var options = siApp.extendOptions(defaultOptions, elem, "ng-si-date-options");
        if (options['ngMinDate'] != null) {
            var min = options['ngMinDate'];
            //we need to set the minDate property based on what we evaluate on an angular scope    
            //options.minDate = scope.$eval(min);
            scope.$watch(min,function(value)
            {
                elem.datepicker("option", "minDate", value);
            });

        }
        if (options['ngMaxDate'] != null) {
            var max = options['ngMaxDate'];
            options.maxDate = scope.$eval(max);
            scope.$watch(max, function (value)
            {
                elem.datepicker("option", "maxDate", value);
            });
        }

        options.onSelect = function (dateVal) {
            var model = $(elem).attr("ng-model");
            scope.$safeApply(function () { $parse(model).assign(scope, dateVal) });

            $(elem).change(); // alert anyone listening to the change event
        };
        elem.datepicker(options);

        scope.$on("$destroy", function ()
        {
            try
            {
                elem.datepicker("destroy");
            }
            catch (e) { };//some of our jquery ui is throwing odd exceptions when it is destroying.
        });
        //NOTE: this generalizes this to some WISE global stuff, but it solves one of our problems for now.
        if (_isIpadUser)
        {
            elem.attr("readonly", true);
        }

        //we don't need a watcher to go from binding to the date picker
    };
}]);

siApp.directive('ngSiModal', function () {
    return {
        link: function postLink(scope, element, attrs)
        {
            var elem = $(element);
            var defaultOptions = { autoOpen: false, position: ['center', 150], modal: true, draggable: true, resizable: true, hide: { effect: "fade", duration: 400 } };

            var options = siApp.extendOptions(defaultOptions, elem, "ng-si-modal-options")

            options = $.extend(defaultOptions, options);
            if (options.ngTitle)
            {
                
                scope.$watch(options.ngTitle, function (value)
                {
                
                    elem.dialog("option", "title", value);
                });
            }
            if (options.ngWidth)
            {
                scope.$watch(options.ngWidth, function (value)
                {
                    elem.dialog("option", "width", value);
                });
            }
            if (options.ngHeight)
            {
                scope.$watch(options.ngHeight, function (value)
                {
                    elem.dialog("option", "height", value);
                });
            }

            options.close = function ()
            {
                siApp.evalAttribute(scope, attrs.ngSiModalClosed);
            };
            var diag = elem.dialog(options);
            scope.$watch(attrs.ngSiModal, function (value)
            {
                if (value) {                    
                    $(element).dialog("open");
                } else
                {
                    $(element).dialog("close");
                }
            });
            
            scope.$on("$destroy", function ()
            {
                try
                {
                    elem.dialog("destroy");
                    elem.remove();
                }
                catch(e){};//for some reason some jquery ui items are throwing exceptions on destroy
            });
        }
    };
});

siApp.directive('ngSiHover', function ()
{
    return function (scope, element, attrs)
    {
        var elem = $(element);
        elem.mouseenter(function ()
        {
            siApp.evalAttribute(scope, attrs.ngSiHover);
        });
    };
});

siApp.directive('ngSiOut', function ()
{
    return function (scope, element, attrs)
    {
        var elem = $(element);
        elem.mouseleave(function () 
        {
            siApp.evalAttribute(scope, attrs.ngSiOut);
        });
    };
});


siApp.directive('ngSiDraggable', function ()
{
    return function (scope, element, attrs)
    {
        var elem = $(element);
        var defaultOptions = { revert: "invalid", revertDuration: 100, scroll: true, distance: 20, helper: "clone", addClasses: false, scrollSensitivity: 60, scrollSpeed: 8, refreshPositions: true, appendTo:'body' };
        var options = siApp.extendOptions(defaultOptions, elem, "ng-si-draggable-options")

        
        //added option that the directive knows how to translate into an actual dom element
        //which is what jquery expects for containment.
        if (options.containmentSelector)
        {
            options.containment = $(options.containmentSelector);
        }
        if (options.cloneSelector)
        {
            options.helper = function (event)
            {
                var elem = $(options.cloneSelector).clone();
                elem.attr("id", elem.attr("id") + "_clone");
                
                setTimeout(
                    function ()
                    {
                        var origElem = $(options.cloneSelector);
                        
                        elem.html(origElem.html());//origElem may have updated binding
                    }, 150);
                return elem;
            }
        }

        options.start = function ()
        {
            if (document.selection)
            {  //IE hack to stop the drag from highlighting text.
                document.selection.empty();
            }
            siApp.evalAttribute(scope, attrs.ngSiDragStart);
            
        };
        options.stop = function ()
        {
            siApp.evalAttribute(scope, attrs.ngSiDragStop);
        };

        elem.draggable(options);
        scope.$watch(attrs.ngSiDraggable, function (value)
        {
            if (value)
            {
                $(element).draggable("enable");
            } else
            {
                $(element).draggable("disable");

            }
        });
    };
}
);

siApp.directive('ngSiDroppable',  function ()
{
    return function (scope, element, attrs)
    {
        var elem = $(element);
        var defaultOptions = { addClasses: false };
        var options = siApp.extendOptions(defaultOptions, elem, "ng-si-droppable-options")

        options.over = function (e, ui)
        {
            siApp.evalAttribute(scope, attrs.ngSiDropHover);
        };
        var acceptFunctionStr = $(element).attr("ng-si-drop-accept");
        if (acceptFunctionStr)
        {
            options.accept = function (e, ui)
            {
                //this one needs an instante true false return, and cannot do anything
                //in the viewmodel that needs to reflect via binding because we can't do it
                //via the scope.apply stuff.
                var scopeOperation = acceptFunctionStr;
                var accept = scope.$eval(scopeOperation || angular.noop);
                return accept;
            };
        }
        options.out = function (e, ui)
        {
            siApp.evalAttribute(scope, attrs.ngSiDropOut);
        };
        options.drop = function (e, ui)
        {
            siApp.evalAttribute(scope, attrs.ngSiDrop);
        };
        elem.droppable(options);
        scope.$watch(attrs.ngSiDroppable, function (value)
        {
            if (value)
            {
                $(element).droppable("enable");
            } else
            {
                $(element).droppable("disable");

            }
        });
    };
});

siApp.directive('template', ['$templateCache', '$compile', function ($templateCache, $compile)
{
    return {
        //restrict: 'A',
        scope: {
            param: "="
        },
        link: function (scope, elm, attrs)
        {
            // Retrieve the HTML (uncompiled)
            var html = $templateCache.get(attrs.templateid);
            if (!html)
            {
                html = $("#" + attrs.templateid).html();
                $templateCache.put(attrs.templateid, html);
            }

            // Inject it into the DOM before compiling
            elm.html(html);
            // Compile / Bind the DOM -- max value ensures that all directives get evaluated...
            $compile(elm.contents())(scope);
            
        }
    };

} ]);


siApp.directive('ngSiOnMaxScrollY', function ()
{
    return function (scope, element, attrs)
    {
        var scrollContainer = $(element); ;

        scrollContainer.scroll(function (e)
        {
            //scrollContainer and e.currentTarget are basically the same thing just one is a jquery obj one isn't.
            var scrollY = e.currentTarget.scrollTop + scrollContainer.height();
            var scrollH = e.currentTarget.scrollHeight;
            var perc = parseInt(attrs.ngSiMaxScrollYPerc);
            var tgtY = scrollH;
            if (isNaN(perc) || perc > 99)
            {
                perc = 99;//IE has some goofyness where it seems to be not quite precise enough for 100% to always work.
            }
            if (perc < 50)
            {
                perc = 50;
            }

            tgtY = (perc / 100) * scrollH;
            
            if (scrollY >= tgtY)
            {
                
                siApp.evalAttribute(scope, attrs.ngSiOnMaxScrollY);
            }


        });

    };
});

siApp.directive('ngSiTrackFocus', function ()
{
    return function (scope, element, attrs)
    {
        var elem = $(element);
        elem.focus(function ()
        {
            var scriptString = attrs.ngSiTrackFocus;
          
            siApp.evalAttribute(scope, scriptString);
        });
        elem.blur(function ()
        {
            var scriptString = attrs.ngSiTrackFocus;
          
            siApp.evalAttribute(scope, scriptString);

        });

    };
});


siApp.directive('ngSiTabs', [function ()
{
    return {
        restrict: 'EA',
        transclude: true,
        scope: {},
        //TODO: we ought to either make this a wiseDirective, or generalize out the template url value
        templateUrl:'../Content/templates/tabTemplate.html',
        controller:['$scope','$element', function($scope, $element) {
            var panes = $scope.panes = [];
            $scope.select = function(pane) 
            {
                angular.forEach(panes, function(pane) 
                {
                    pane.selected = false;
                });
                pane.selected = true;
            
            }

            this.addPane = function(pane) 
            {
                if (panes.length == 0)
                {
                    $scope.select(pane);
                }
                panes.push(pane);
            }
        }],
        replace: true
    };
}]);

siApp.directive('ngSiPane', [function() 
{
    return {
        require: '^ngSiTabs',
        restrict: 'EA',
        transclude: true,
        scope: { title: '@' },
        //TODO: we ought to either make this a wiseDirective, or generalize out the template url value
        templateUrl: "../Content/templates/paneTemplate.html",
        link: function(scope, element, attrs, tabsCtrl) {
            tabsCtrl.addPane(scope);
        },
        replace: true
    };
}])


siApp.directive("ngSiFile", function ()
{
    return{
        restrict: "A",
        scope:true,
        link:function(scope,elem,attrs)
        {
            elem.bind('change', function (event)
            {
                var f;
                if (event.target.files)
                {//IE doesn't appear to allow you to tell what is in the file in javascript!
                    f = event.target.files[0];
                }
                
                var eventName = attrs.ngSiFile;
                if (!eventName)
                {
                    eventName = "fileSelected";
                }
                //dispatches an event that our parent scope can listen for
                //so our parent needs to listen to fileSelected to get a file
                scope.$emit(eventName, { file: f, picker:elem });
                
            });
        }
    }
});


siApp.directive('ngSiError', function () {
    return function (scope, element, attrs) {
        scope.allGKs = [];
        scope.$watch(attrs.ngSiError, function (newValue, oldValue) {
            if (newValue) {
                //We have an error, the jQuery below will get it
            }
            else {
                // When the error is gone, remove the error div
                $("div.GKHover").remove();
                scope.allGKs.length = 0;
            }
        }, true);
        $('.GKError').live('hover', function () {
            var id = this.name;
            if ($.inArray(id, scope.allGKs) < 0) { // this check reduces the number of redundant calls to gatekeeperBox
                scope.allGKs.push(id);
                window.gatekeeperBox(this, window.GK_required); // for now, hard code all of them to have the same error text
            }
        });

    };
});
